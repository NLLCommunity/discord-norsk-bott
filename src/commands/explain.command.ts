import { Injectable, Logger } from '@nestjs/common';
import {
  Command,
  Handler,
  InteractionEvent,
  Param,
  ParamType,
} from '@discord-nestjs/core';
import { SlashCommandPipe } from '@discord-nestjs/common';
import {
  PermissionFlagsBits,
  type ChatInputCommandInteraction,
} from 'discord.js';
import {
  ExplanationProvider,
  RateLimiterProvider,
  ShowEveryoneProvider,
} from '../providers';
import { ShowEveryoneParamEn } from 'src/utils';

export class ExplainCommandParams {
  @Param({
    name: 'text',
    description: 'The word or phrase to explain.',
    required: true,
    type: ParamType.STRING,
  })
  text: string;

  @ShowEveryoneParamEn()
  showEveryone: boolean;
}

/**
 * Explains a word or phrase.
 */
@Injectable()
@Command({
  name: 'explain',
  description: 'Explains a word or phrase',
  defaultMemberPermissions: PermissionFlagsBits.SendMessages,
})
export class ExplainCommand {
  constructor(
    private readonly explainer: ExplanationProvider,
    private readonly showEveryone: ShowEveryoneProvider,
    private readonly rateLimiter: RateLimiterProvider,
  ) {}

  #logger = new Logger(ExplainCommand.name);

  /**
   * Handles the command.
   * @param interaction The interaction event.
   * @param params The command parameters.
   */
  @Handler()
  async handle(
    @InteractionEvent() interaction: ChatInputCommandInteraction,
    @InteractionEvent(SlashCommandPipe)
    { text, showEveryone }: ExplainCommandParams,
  ): Promise<void> {
    this.#logger.log(`Explaining a word or phrase`);

    if (!this.explainer.isAvailable) {
      await interaction.reply({
        content:
          'This command is not available because it has not been configured.',
        ephemeral: true,
      });

      return;
    }

    if (
      showEveryone &&
      this.rateLimiter.isRateLimited(ExplainCommand.name, interaction, {
        maxPerWindow: 5,
        window: 30 * 60 * 1000, // 30 minutes
      })
    ) {
      return;
    }

    await interaction.deferReply({
      ephemeral: !showEveryone,
    });

    try {
      const response = await this.explainer.explain(text);

      if (!response) {
        this.#logger.warn('Failed to explain message');
        interaction.editReply('Failed to explain message.');
        return;
      }

      let summary = `> ⚠️ **Note:** This explanation is generated by an AI model and may not be accurate or vary each time it is generated. For the most accurate information, please ask a human expert.
> _Did you know we pay for every explanation? Help us offer explanations by [donating to Ada](https://github.com/sponsors/adalinesimonian)._

`;
      let lastLength = 0;

      const interval = setInterval(() => {
        if (summary.length === lastLength) {
          return;
        }

        lastLength = summary.length;

        interaction.editReply(summary + '▮').catch((error) => {
          this.#logger.error('Failed to update explanation', error);
        });
      }, 500);

      for await (const chunk of response) {
        summary += chunk.choices[0]?.delta.content ?? '';

        if (summary.length >= 2000) {
          const tooLong = '…\n\n**Explanation too long, truncating here.**';

          summary = summary.slice(0, 2000 - tooLong.length) + tooLong;

          response.controller.abort();

          break;
        }
      }

      clearInterval(interval);
      await interaction.editReply({
        content: summary,
        components: showEveryone ? [] : [this.showEveryone.getActionRow()],
      });
    } catch (err) {
      this.#logger.error('Failed to explain message', err);
      interaction.editReply('Failed to explain message.');
    }
  }
}
